---
sidebar: sidebar
permalink: solutions/ontap-day01-deploy.html
keywords: bluexp automation catalog, netapp automation solutions, ontap day 0/1, deploy
summary:
---

= Deploy the ONTAP day 0/1 solution
:hardbreaks:
:nofooter:
:icons: font
:linkattrs:
:imagesdir: ./media/

[.lead]
After completing the preparation and planning, you are now ready to deploy the ONTAP day 0/1 solution to quickly configure an ONTAP cluster using Ansible. 

At any time during this procedure, you can choose to test a request instead of executing it. To do this, you must change the site.yml playbook on the command line to use logic.yml. 

The docs/tutorial-requests.txt file contains the final version of all service requests used throughout this procedure. If you have difficulty running a service request, you can copy the relevant request from the tutorial-requests.txt file to the playbooks/inventory/group_vars/all/tutorial-requests.yml location and modify the hard coded values as required (IP address, aggregate names and so on). You should then be able to successfully make the request. 

== Before you begin

>> Summary of what's needed with bullet list
>> In particular, Ansible installed, solution downloaded and unzipped and files in place
>> Have ONTAP system ready with credentials
>> link to "prepare" topic for details

== Step 1: Initial cluster configuration

At this stage, you must perform some initial cluster configuration steps. 

. Navigate to the `playbooks/inventory/group_vars/all/tutorial-requests.yml` location and review the `cluster_initial` request in the file. Make any necessary changes to suite your environment. 
+
License codes in this sample are for node 1 in an ONTAP simulator running ONTAP 9.9. At the bottom of the file uncomment the `raw_service_request` definition and confirm that the value is set to `cluster_initial`.
+
NOTE: The examples in this procedure use "ONTAP99_01" and "ONTAP99_02" as the names for the two clusters. Replace these values with the names of the clusters in your environment. 

. Perform the initial cluster configuration for the first cluster:
+
[source,cli]
ansible-playbook -i inventory/hosts site.yml -e cluster_name=ONTAP99_01

. Verify that there are no errors and repeat the command for the second cluster:
+
[source,cli]
ansible-playbook -i inventory/hosts site.yml -e cluster_name=ONTAP99_02
+
Verify there are no errors for the second cluster.
+
When you scroll up towards the beginning of the Ansible output you should see the request that was sent to the framework, as shown in the following example:
+
----
TASK [Show the raw_service_request] ********************************************************
ok: [localhost] => {
"raw_service_request": {
2
"operation": "create",
"req_details": {
"ontap_aggr": [
{
"disk_count": 24,
"hostname": "ONTAP99_01",
"name": "n01_aggr1",
"nodes": "ONTAP99_01-01",
"raid_type": "raid4"
}
],
"ontap_license": [
{
"hostname": "ONTAP99_01",
"license_codes": [
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA"
3
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA",
"XXXXXXXXXXXXXXXAAAAAAAAAAAAA"
]
}
],
"ontap_motd": [
{
"hostname": "ONTAP99_01",
"message": "New MOTD",
"vserver": "ONTAP99_01"
}
]
},
"service": "cluster_initial",
"std_name": "none"
}
}
----

. Log in to your ONTAP instances and verify that the request was executed
correctly.

=== Configuration changes after the initial cluster configuration

This example shows you how to make configuration changes after the initial cluster configuration. This example demonstrates how to add intercluster LIFs to the configuration if they were not added during the original request. 

.Steps 

. Modify the `cluster_initial` request in `tutorial-requests.yml` file by adding the following lines to the request definition:
+
----
ontap_interface:
- hostname: "{{ cluster_name }}"
vserver: "{{ cluster_name }}"
interface_name: ic01
role: intercluster
address: <ip_address>
netmask: <netmask_address>
home_node: "{{ cluster_name }}-01"
home_port: e0c
ipspace: Default
use_rest: never
- hostname: "{{ cluster_name }}"
vserver: "{{ cluster_name }}"
interface_name: ic02
role: intercluster
address: <ip_address>
netmask: <netmask_address>
home_node: "{{ cluster_name }}-01"
4
home_port: e0c
ipspace: Default
use_rest: never
- hostname: "{{ peer_cluster_name }}"
vserver: "{{ peer_cluster_name }}"
interface_name: ic01
role: intercluster
address: <ip_address>
netmask: <netmask_address>
home_node: "{{ peer_cluster_name }}-01"
home_port: e0c
ipspace: Default
use_rest: never
- hostname: "{{ peer_cluster_name }}"
vserver: "{{ peer_cluster_name }}"
interface_name: ic02
role: intercluster
address: <ip_address>
netmask: <netmask_address>
home_node: "{{ peer_cluster_name }}-01"
home_port: e0c
ipspace: Default
use_rest: never
----
. Run the following command:
+
[source, cli]
ansible-playbook -i inventory/hosts site.yml -e cluster_name=<ONTAP99_01>
-e peer_cluster_name=ONTAP99_02

. Log in to each instance and to check if the LIFs have been added: 
+
+
In this example, the output shows that the LIFs have not yet been added. This is because the ontap_interface


== Step 3: Initial SVM configuration

At this stage in the procedure, you configure the SVMs in the cluster.

. Update the `svm_initial` request in the `tutorial-requests.yml` file to configure an SVM and SVM peer relationship. 
+
You must configure the following:
+
* The SVM
* The SVM peer relationship
* The SVM interface for each SVM.


. Update the variable definitions in the `svm_initial` request definitions. You must modify the following variable definitions: 
+
* `cluster_name`
* `vserver_name` 
* `peer_cluster_name`
* `peer_vserver`
+
To update the definitions, remove the ‘{}’ after `req_details` for the `svm_initial` definition and add the correct definition.

. After you have properly defined the request, update the `raw_service_request` field at the end of the file to use the `svm_initial` request, as shown in the following example:
+
----
raw_service_request: "{{ svm_initial }}"
----

. Run the request:
[source, cli]
ansible-playbook -i inventory/hosts -e cluster_name=ONTAP99_01 -e
peer_cluster_name=ONTAP99_02 -e peer_vserver=app02 -e vserver_name=app01

. Log in to each ONTAP instance and validate the configuration.
+
NOTE: At this stage, the interfaces are not configured. Figure out why, fix
it, and execute Ansible again. Refer to docs/tutorial-requests.txt for svm_initial and read the comment.

== Step 4: Provision NAS

In the previous steps, the raw_service_request is hard coded. This is useful for learning, development, and testing. You can also dynamically generate a `raw_service_request`. The following steps also describe a method that hard
codes the request, but can be extended to generate it dynamically.

The framework provides facility to dynamically produce the required `raw_service_request `when the customer does not want to integrate it
with higher level systems. Using this facility requires the following

. Comment out the `raw_service_request` definition at the bottom of the `tutorial-requests.yml file` 
. Open the `playbooks/logic-tasks/tutorial.yml` file

. Define the `logic_operation` variable
+
If the logic_operation variable is not defined the logic.yml file does not import any file from logic-tasks. This means the `raw_service_request` must be defined
outside of Ansible and passed to the framework on execution. 
+
A tasks file name in logic-tasks must match the value of the logic_operation variable and the yml extension.
+
The tasks file in logic-tasks dynamically defines a `raw_service_request`. The only requirement is that a valid `raw_service_request` be defined as the last task in the file.
+
. Dynamically define the the service request. 
+
There are multiple ways to apply the logic task to dynamically define a service request. Some of these options are listed below:
+
* Using the Ansible task code within the file itself
* Invoking a custom role that returns data suitable for converting to a raw_service_request or the request itself
* Invoking another tool outside Ansible to provide the data require. For example, a  REST call to Active IQ Unified Manager) 
* Invoking other tasks files from within logic-tasks to organize operations
+
The following example commands dynamically define a service request for both clusters:
+
----
ansible-playbook -i inventory/hosts -e cluster2provision=ONTAP99_01
-e logic_operation=tutorial site.yml

ansible-playbook -i inventory/hosts -e cluster2provision=ONTAP99_02
-e logic_operation=tutorial site.yml
----
== Step 5: Complete configuration


